class Background {
    static BGM_NUM = 4;
    static INTERVAL_OF_BGM = 11400; //約3分10秒
    static loadBGMS() {
        Background.BGMS = new Array(Background.BGM_NUM);
        for (let i = 0; i < Background.BGM_NUM; i++) {
            Background.BGMS[i] = loadSound(`assets/sound/bgm${i}.mp3`);
        }
        Background.BLOCK_DESTROY = loadSound("assets/sound/block_destroy.mp3");
        Background.GAMEOVER = loadSound("assets/sound/game_over.mp3");
    }
    
    static set() {
        Background.indexOfBGM = 3;
        Background.playingCount = 10**9;
        MyFunctions.shuffle(Background.BGMS);
    }

    static pause() {
        Background.BGMS[Background.indexOfBGM].pause();
        Background.playingCount = 0;
    }

    static loopBGM() {
        if (Background.playingCount > Background.INTERVAL_OF_BGM && keyIsPressed) {
            Background.indexOfBGM = (Background.indexOfBGM + 1) % Background.BGM_NUM;
            Background.playingCount = 0;
            Background.BGMS[Background.indexOfBGM].play();
        } else {
            Background.playingCount++;
        }
    }
}

class Block {
    static L = 20;

    constructor(x, y, pattern = 0) {
        this.x = x;
        this.y = y;
        this.design = Pattern.DESINGS[pattern]; //ブロックを装飾する画像
        this.lit = false; //ブロックを表示させるかどうか
        this.isLocked = false; //ブロックが固定されるかどうか(アクティブなミノ以外のブロックは全て固定されている。)
        Object.seal(this);
    }

    getLit() {
        return this.lit;
    }
    
    setLit(lit) {
        this.lit = lit;
    }

    getIsLocked() {
        return this.isLocked;
    }
    
    setIsLocked(isLocked) {
        this.isLocked = isLocked;
    }

    getDesign() {
        return this.design;
    }

    setDesign(design) {
        this.design = design;
    }

    clone(block) {
        this.design = block.design;
        this.lit = block.lit;
        this.isLocked = block.isLocked;
    }

    draw() {
        if (!this.lit) { return; }
        image(this.design, this.x, this.y, Block.L, Block.L);
    }
}

class Game {
    static W = 15; //座標の横幅
    static H = 32; //座標の縦幅
    static START_X = 6; //ミノ生成時の座標X
    static START_Y = 1; //ミノ生成時の座標Y
    static DEFAULT_FALL_SPEED = 30; //ミノが落下するスピード
    
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.field = new Array(Game.H);
        this.fallSpeed = Game.DEFAULT_FALL_SPEED;
        this.top = Game.H - 1;
        this.score = 0;
        this.combo = 0;
        this.scoreElement = $("#score");
        this.comboElement = $("#combo");
        this.timerElement = $("#timer");
        this.timeLimit = 180; //タイムリミット３分
        this.variablesForGameOver = {
            isGameOver: false,
            red: 0
        };
        for (let i = 0; i < Game.H; i++) {
            this.field[i] = new Array();
            for (let j = 0; j < Game.W; j++) {
                let block = new Block(this.x + j * Block.L + 2 * j, this.y + i * Block.L + 2 * i, Pattern.NUM);
                if (i == Game.H - 1 || j == 0 || j == Game.W - 1) {
                    block.setLit(true);
                    block.setIsLocked(true);
                }
                this.field[i].push(block);
            }
        }
        this.activeMino = Mino.createMino(Game.START_X, Game.START_Y, true, this); //色々あってコンストラクタの最後にミノ作成
        Object.seal(this);
    }

    getBlock(i, j) {
        return this.field[i][j];
    }

    // i行目のブロックを全てd個ずらす
    shift(i, d) {
        if (i - d > 0) {
            let line1 = this.field[i - d];
            let line2 = this.field[i];
            for (let j = 1; j < Game.W - 1; j++) {
                line2[j].clone(line1[j]);
            }
        } else {
            console.log("i - d <= 0", i, d);
            let line = this.field[i];
            for (let j = 1; j < Game.W - 1; j++) {
                line[j].setLit(false);
                line[j].setIsLocked(false);
            }
        };
    }

    // ブロック破壊
    breakOut() {
        let i;
        for (i = Game.H - 2; i >= this.top; i--) {
            if (this.field[i].every(block => block.getLit())) {
                i;
                break;
            }
        }
        let start = i;
        for (i = start; i >= this.top; i--) {
            if (this.field[i].some(block => !block.getLit())) {
                break;
            }
        }
        
        let count = start - i;
        if (count == 0) {
            this.combo = 0;
            this.reloadCombo();
            return;
        }
        for (let i = start; i >= this.top; i--) {
            this.shift(i, count);
        }
        this.top += count;
        this.combo++;
        this.score += this.combo * (Game.W - 2) * count * 100;
        this.reloadCombo();
        this.reloadScore();
        Background.BLOCK_DESTROY.play();
    }

    // 画面上のスコアを更新
    reloadScore() {
        this.scoreElement.text(this.score);
    }
    
    // 画面上のコンボを更新
    reloadCombo() {
        this.comboElement.text(this.combo);
    }
    
    // 画面上の制限時間を更新
    reloadTimer() {
        this.timerElement.text(this.timeLimit);
    }

    //ゲームオーバー画面を表示
    gameOver() {
        textSize(50);
        fill(this.variablesForGameOver.red, 0, 0);
        this.variablesForGameOver.red++;
        text("Game Over", this.x + 26, this.y + 350);
        for (let i = 0; i < Game.H; i++) {
            this.field[i][0].draw();
        }
        
        for (let i = 0; i < Game.H; i++) {
            this.field[i][Game.W - 1].draw();
        }
        
        for (let i = 1; i < Game.W - 1; i++) {
            this.field[Game.H - 1][i].draw();
        }
    }

    draw() {
        if (this.variablesForGameOver.isGameOver) {
            this.gameOver();
            return;
        }
       
        // ここでブロック表示
        for (let i = 0; i < Game.H; i++) {
            for (let j = 0; j < Game.W; j++) {
                this.field[i][j].draw();
            }
        }

        if (frameCount % 60 == 0) {
            this.reloadTimer();
            this.timeLimit--;
        }
        // タイムオーバー
        if (this.timeLimit < 0) {
            this.variablesForGameOver.isGameOver = true;
            Background.pause();
            Background.GAMEOVER.play();
            return;
        }

        // ここで不要になったactiveMinoの中身は開放されてるはず。。。
        if (!this.activeMino.isActive) {
            this.activeMino = Mino.createMino(Game.START_X, Game.START_Y, true, this);
            if (this.activeMino === null) {
                this.variablesForGameOver.isGameOver = true;
                Background.pause();
                Background.GAMEOVER.play();
                return;
            }
        }

        this.activeMino.draw(this);
    }

    // this.fieldを行列の形で表示
    showField() {
        for (let i = 0; i < Game.H; i++) {
            let temp = this.field[i].map((block) => {
                return Number(block.getLit());
            });
            console.log(temp.toString());
        }
    }
}

"use strict"

let player;

function preload() {
    Background.loadBGMS(); //BGM用の音楽読み込み
    Pattern.setDesign(); //ブロック用の画像読み込み
}

function setup() {
    let screen = createCanvas(1280, 800);
    Background.set();
    screen.parent("screen");
    player = new Player(490, 50);
}

function draw() {
    background(0);
    Background.loopBGM();
    player.draw();
    // MyFunctions.showMemory(180);
}

/* TODO:
    function judgeLeft(field)といった記述を
    geme.judgeLeft(this)のように修正。
    P.S.
    と思ったけど、やっぱりこのままでもいいかも？
*/

class Mino {
    static NUM = 4;
    
    constructor(x, y, pattern, isActive) {
        this.x = x;
        this.y = y;
        this.pattern = pattern; //デザイン
        this.blocks = new Array(Mino.NUM); //ミノはブロックの塊である
        for (let i = 0; i < Mino.NUM; i++) {
            this.blocks[i] = [x + Pattern.SHAPES[pattern][i][0], y + Pattern.SHAPES[pattern][i][1]];
        }
        this.isActive = isActive; //現在操作中のミノ
    }

    // ランダムな種類のミノを一つ生成
    static createMino(x, y, isActive, game) {
        let pattern = Math.floor(Math.random() * Pattern.NUM);
        let mino = new Mino(x, y, pattern, isActive);
        if (mino.blocks.some(m => game.getBlock(m[1], m[0]).getIsLocked())) {
            mino = null;
        }
        return mino;
    }
    

    // 画面左の衝突判定
    judgeLeft(field) {
        return this.blocks.some(m => field[m[1]][m[0] - 1].getIsLocked());
    }
    
    // 画面右の衝突判定
    judgeRight(field) {
        return this.blocks.some(m => field[m[1]][m[0] + 1].getIsLocked());
    }
    
    // 画面下の衝突判定
    judgeBottom(field) {
        return this.blocks.some(m => field[m[1] + 1][m[0]].getIsLocked());
    }

    // 左に1マス移動
    moveLeft(field) {
        if (this.judgeLeft(field)) { return; }
        this.x -= 1;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            field[m[1]][m[0]].setLit(false);
            m[0] -= 1;
        }
    }
    
    // 右に1マス移動
    moveRight(field) {
        if (this.judgeRight(field)) { return;}
        this.x += 1;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            field[m[1]][m[0]].setLit(false);
            m[0] += 1;
        }
    }

    // 下に1マス移動
    moveDown(field) {
        if (this.judgeBottom(field)) {
            // this.isActive = false;
            return;
        }
        this.y += 1;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            field[m[1]][m[0]].setLit(false);
            m[1] += 1;
        }
    }

    /* 
    回転時のバグ対策用に、
    ２次元配列をコピーする関数を簡易的に作った。
    */
    static myCopy(ary) {
        let result = new Array(Mino.NUM);
        for (let i = 0; i < Mino.NUM; i++) {
            result[i] = [ary[i][0], ary[i][1]];
        }
        return result;
    }

    /*
        回転には行列の考え方を利用した。
        コードは長くなったが、
        要は回転後にミノが他のブロックとぶつかったりする場合、
        回転をなかったことにする。(データベースのトランザクション的な)
    */
    // 左に90度回転
    rotateLeft(field) {
        let ary = Mino.myCopy(this.blocks);
        try {
            let overBottom = 0;
            for (let i = 0; i < Mino.NUM; i++) {
                let m = this.blocks[i];
                field[m[1]][m[0]].setLit(false);
                let x = m[0] - this.x;
                let y = m[1] - this.y;
                [x, y] = [-y, x];
                [m[0], m[1]] = [this.x + x, this.y + y];

                if (m[1] >= Game.h || field[m[1]][m[0]]) {
                    let temp = 0;
                    let d = m[1];
                    while (d >= Game.h || field[d][m[0]].getIsLocked()) {
                        d--;
                        temp++;
                    }
                    overBottom = max(overBottom, temp);
                }

            }

            for (let i = 0; i < Mino.NUM; i++) {
                this.y -= overBottom;
                this.blocks[i][1] -= overBottom;
            }
        } catch (e) {
            if (e instanceof TypeError) {
                this.blocks = ary;
            } else {
                console.error(e);
            }
        }
    }
    
    // 右に90度回転
    rotateRight(field) {
        let ary = Mino.myCopy(this.blocks);
        try {
            let overBottom = 0;
            for (let i = 0; i < Mino.NUM; i++) {
                let m = this.blocks[i];
                field[m[1]][m[0]].setLit(false);
                let x = m[0] - this.x;
                let y = m[1] - this.y;
                [x, y] = [y, -x];
                [m[0], m[1]] = [this.x + x, this.y + y];

                if (m[1] >= Game.h || field[m[1]][m[0]]) {
                    let temp = 0;
                    let d = m[1];
                    while (d >= Game.h || field[d][m[0]].getIsLocked()) {
                        d--;
                        temp++;
                    }
                    overBottom = max(overBottom, temp);
                }
            }

            for (let i = 0; i < Mino.NUM; i++) {
                this.y -= overBottom;
                this.blocks[i][1] -= overBottom;
            }
        } catch (e) {
            if (e instanceof TypeError) {
                this.blocks = ary;
            } else {
                console.error(e);
            }
                
        }
    }

    // 着地したブロックを固定
    lock(game) {
        let field = game.field;
        let top = 10 ** 9;;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i];
            field[m[1]][m[0]].setLit(true);
            field[m[1]][m[0]].setIsLocked(true);
            top = min(top, m[1]);
        }
        this.isActive = false;
        game.top = min(game.top, top);
    }
    
    draw(game) {
        let field = game.field;
        if (!this.isActive) {
            return;
        }
        if (this.judgeBottom(field) && frameCount % 30 == 0) {
            this.lock(game);
            game.breakOut();
            return;
        }
        
        // キーボード ["j", "k", "l", "a", "d"] でミノを操作
        if (keyIsPressed && frameCount % 6 == 0) {
            switch (key) {
                case "j": //左に1マス移動
                    this.moveLeft(field);
                    break
                    case "k": //下に2マス移動
                        this.moveDown(field);
                        this.moveDown(field);
                        this.moveDown(field);
                    break;
                case "l": //右に1マス移動
                    this.moveRight(field);
                    break
                case "a": //左に90度回転
                    this.rotateLeft(field);
                    break;
                case "d": //右に90度回転
                    this.rotateRight(field);
                    break;
            }
        }

        //game.fallSpeedミリ秒おきに下に移動
        if (frameCount % game.fallSpeed === 0) {
            this.moveDown(field);
        }

        // ここでミノを表示
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            let block = field[m[1]][m[0]]
            block.setDesign(Pattern.DESINGS[this.pattern]);
            block.setLit(true);
        }
    }
}

class MyFunctions {
    // メモリ使用率表示
    static showMemory(permiliseconds) {
        if (frameCount % permiliseconds !== 0) { return; }
        let memory = performance.memory;
        console.log(memory);
        let x = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
        console.log(`メモリ使用率: ${x * 100} %`);
        console.log(`----稼働時間: ${frameCount / 60}秒----`)
    }
    
    // 配列をシャッフル
    static shuffle(ary) {
        let len = ary.length;
        for (let i = len - 1; i >= 0; i--) {
            let j = Math.floor(Math.random() * i);
            [ary[i], ary[j]] = [ary[j], ary[i]];
        }
    }
}

class Pattern {
    static NUM = 7;

    static SHAPES = [
        [[-1, 0], [0, -1], [0, 0], [1, 0]], //凸
        [[0, 0], [0, 1], [1, 1], [2, 1]], //「
        [[0, 0], [1, 0], [2, 0], [2, -1]],　// 「の反対
        [[0, 0], [1, 0], [1, 1], [0, 1]], //口
        [[0, -1], [0, 0], [0, 1], [0, 2]], //|
        [[-1, 0], [0, 0], [0, 1], [1, 1]], //乙
        [[-1, 0], [0, 0], [0, -1], [1, -1]], //乙の反対
    ];

    static DESINGS = new Array(Pattern.NUM + 1);
    static setDesign() {
        for (let i = 0; i < Pattern.NUM + 1; i++) {
            Pattern.DESINGS[i] = loadImage(`assets/img/pattern${i}.png`);
        }
    }

}

class Player {
    constructor(x, y) {
        this.game = new Game(x, y);
        Object.seal(this);
    }

    draw() {
        this.game.draw();
    }
}
