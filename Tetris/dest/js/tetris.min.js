class Background {
    static BGM_NUM = 4;
    static INTERVAL_OF_BGM = 11400; //約3分10秒
    static loadBGMS(p) {
        Background.BGMS = new Array(Background.BGM_NUM);
        for (let i = 0; i < Background.BGM_NUM; i++) {
            Background.BGMS[i] = p.loadSound(`assets/sound/bgm${i}.mp3`);
        }
        Background.BLOCK_DESTROY = p.loadSound("assets/sound/block_destroy.mp3");
        Background.GAMEOVER = p.loadSound("assets/sound/game_over.mp3");
    }
    
    static set() {
        Background.indexOfBGM = 3;
        Background.playingCount = 10**9;
        Mylib.shuffle(Background.BGMS);
    }

    static pause() {
        Background.BGMS[Background.indexOfBGM].pause();
        Background.playingCount = 0;
    }

    static loopBGM(p) {
        if (Background.playingCount > Background.INTERVAL_OF_BGM && p.keyIsPressed) {
            Background.indexOfBGM = (Background.indexOfBGM + 1) % Background.BGM_NUM;
            Background.playingCount = 0;
            Background.BGMS[Background.indexOfBGM].play();
        } else {
            Background.playingCount++;
        }
    }
}

class Block {
    static L = 20;

    constructor(p, x, y, pattern = 0) {
        this.p = p;
        this.x = x;
        this.y = y;
        this.design = pattern; //ブロックを装飾する画像
        this.lit = false; //ブロックを表示させるかどうか
        this.isLocked = false; //ブロックが固定されるかどうか(アクティブなミノ以外のブロックは全て固定されている。)
        Object.seal(this);
    }

    getLit() {
        return this.lit;
    }
    
    setLit(lit) {
        this.lit = lit;
    }

    getIsLocked() {
        return this.isLocked;
    }
    
    setIsLocked(isLocked) {
        this.isLocked = isLocked;
    }

    getDesign() {
        return this.design;
    }

    setDesign(design) {
        this.design = design;
    }

    clone(block) {
        this.design = block.design;
        this.lit = block.lit;
        this.isLocked = block.isLocked;
    }

    draw() {
        if (!this.lit) { return; }
        this.p.image(Pattern.DESINGS[this.design], this.x, this.y, Block.L, Block.L);
    }
}

class Game {
    static W = 15; //座標の横幅
    static H = 32; //座標の縦幅
    static START_X = 6; //ミノ生成時の座標X
    static START_Y = 1; //ミノ生成時の座標Y
    static DEFAULT_FALL_SPEED = 30; //ミノが落下するスピード
    
    constructor(p, x, y) {
        this.p = p;
        this.x = x;
        this.y = y;
        this.field = new Array(Game.H);
        this.fallSpeed = Game.DEFAULT_FALL_SPEED;
        this.top = Game.H - 1;
        this.score = 0;
        this.combo = 0;
        this.scoreX = x - 312;
        this.scoreY = y - 2;
        this.timerX = x + 456;
        this.timerY = y + 100;
        this.timeLimit = 180; //タイムリミット３分
        this.variablesForGameOver = {
            isGameOver: false,
            red: 0
        };

        // スコア用のテキスト設定
        this.p.textSize(35);
        this.p.textAlign(this.p.RIGHT);
        this.p.fill(255);

        for (let i = 0; i < Game.H; i++) {
            this.field[i] = new Array();
            for (let j = 0; j < Game.W; j++) {
                let block = new Block(p, this.x + j * Block.L + 2 * j, this.y + i * Block.L + 2 * i, Pattern.NUM);
                if (i == Game.H - 1 || j == 0 || j == Game.W - 1) {
                    block.setLit(true);
                    block.setIsLocked(true);
                }
                this.field[i].push(block);
            }
        }
        this.activeMino = Mino.createMino(p, Game.START_X, Game.START_Y, true, this); //色々あってコンストラクタの最後にミノ作成
    }

    getBlock(i, j) {
        return this.field[i][j];
    }

    // i行目のブロックを全てd個ずらす
    shift(i, d) {
        if (i - d > 0) {
            let line1 = this.field[i - d];
            let line2 = this.field[i];
            for (let j = 1; j < Game.W - 1; j++) {
                line2[j].clone(line1[j]);
            }
        } else {
            let line = this.field[i];
            for (let j = 1; j < Game.W - 1; j++) {
                line[j].setLit(false);
                line[j].setIsLocked(false);
            }
        };
    }

    // ブロック破壊
    breakOut() {
        let i;
        for (i = Game.H - 2; i >= this.top; i--) {
            if (this.field[i].every(block => block.getLit())) {
                i;
                break;
            }
        }
        let start = i;
        for (i = start; i >= this.top; i--) {
            if (this.field[i].some(block => !block.getLit())) {
                break;
            }
        }
        
        let count = start - i;
        if (count == 0) {
            this.combo = 0;
            return;
        }
        for (let i = start; i >= this.top; i--) {
            this.shift(i, count);
        }
        this.top += count;
        this.combo++;
        this.score += this.combo * (Game.W - 2) * count * 100;
        Background.BLOCK_DESTROY.play();
    }
    
    // 画面上の制限時間を更新
    updateTimer() {
        if (this.p.frameCount % 60 === 0) {
            this.timeLimit--;
        }
    }

    showScoreBoad() {
        this.p.image(Pattern.scoreBoad, this.scoreX, this.scoreY);
        this.p.text(this.score, this.scoreX + 300, this.scoreY + 50);
        this.p.text(this.combo, this.scoreX + 300, this.scoreY + 118);
    }

    showTimer() {
        this.p.push();
        this.p.textSize(60);
        this.p.fill(this.p.color(61, 61, 243));
        this.p.text(this.timeLimit, this.timerX, this.timerY);
        this.p.pop();
    }

    setGameOver() {
        this.variablesForGameOver.isGameOver = true;
        Background.pause();
        Background.GAMEOVER.play();
    }

    //ゲームオーバー画面を表示
    gameOver() {
        this.p.push();
        this.p.textSize(50);
        this.p.textAlign(this.p.LEFT);
        this.p.fill(this.variablesForGameOver.red, 0, 0);
        this.variablesForGameOver.red++;
        this.p.text("Game Over", this.x + 26, this.y + 350);
        this.p.pop();
        for (let i = 0; i < Game.H; i++) {
            this.field[i][0].draw();
        }
        
        for (let i = 0; i < Game.H; i++) {
            this.field[i][Game.W - 1].draw();
        }
        
        for (let i = 1; i < Game.W - 1; i++) {
            this.field[Game.H - 1][i].draw();
        }
    }


    draw() {
        this.showScoreBoad();
        this.showTimer();

        if (this.variablesForGameOver.isGameOver) {
            this.gameOver();
            return;
        }
       
        // ここでブロック表示
        for (let i = 0; i < Game.H; i++) {
            for (let j = 0; j < Game.W; j++) {
                this.field[i][j].draw();
            }
        }

        this.updateTimer();

        // タイムオーバー
        if (this.timeLimit <= 0) {
            this.setGameOver();
            return;
        }

        // ここで不要になったactiveMinoの中身は開放されてるはず。。。
        if (!this.activeMino.isActive) {
            this.activeMino = Mino.createMino(this.p, Game.START_X, Game.START_Y, true, this);
            if (this.activeMino === null) {
                this.setGameOver();
                return;
            }
        }

        this.activeMino.draw(this);
    }
}

class Mino {
    static NUM = 4;
    
    constructor(p, x, y, pattern, isActive) {
        this.p = p;
        this.x = x;
        this.y = y;
        this.pattern = pattern; //デザイン
        this.blocks = new Array(Mino.NUM); //ミノはブロックの塊である
        for (let i = 0; i < Mino.NUM; i++) {
            this.blocks[i] = [x + Pattern.SHAPES[pattern][i][0], y + Pattern.SHAPES[pattern][i][1]];
        }
        this.isActive = isActive; //現在操作中のミノ
    }

    // ランダムな種類のミノを一つ生成
    static createMino(p, x, y, isActive, game) {
        let pattern = Math.floor(Math.random() * Pattern.NUM);
        let mino = new Mino(p, x, y, pattern, isActive);
        if (mino.blocks.some(m => game.getBlock(m[1], m[0]).getIsLocked())) {
            mino = null;
        }
        return mino;
    }
    

    // 画面左の衝突判定
    judgeLeft(field) {
        return this.blocks.some(m => field[m[1]][m[0] - 1].getIsLocked());
    }
    
    // 画面右の衝突判定
    judgeRight(field) {
        return this.blocks.some(m => field[m[1]][m[0] + 1].getIsLocked());
    }
    
    // 画面下の衝突判定
    judgeBottom(field) {
        return this.blocks.some(m => field[m[1] + 1][m[0]].getIsLocked());
    }

    // 左に1マス移動
    moveLeft(field) {
        if (this.judgeLeft(field)) { return; }
        this.x -= 1;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            field[m[1]][m[0]].setLit(false);
            m[0] -= 1;
        }
    }
    
    // 右に1マス移動
    moveRight(field) {
        if (this.judgeRight(field)) { return;}
        this.x += 1;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            field[m[1]][m[0]].setLit(false);
            m[0] += 1;
        }
    }

    // 下に1マス移動
    moveDown(field) {
        if (this.judgeBottom(field)) {
            // this.isActive = false;
            return;
        }
        this.y += 1;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            field[m[1]][m[0]].setLit(false);
            m[1] += 1;
        }
    }

    /* 
    回転時のバグ対策用に、
    ２次元配列をコピーする関数を簡易的に作った。
    */
    static myCopy(ary) {
        let result = new Array(Mino.NUM);
        for (let i = 0; i < Mino.NUM; i++) {
            result[i] = [ary[i][0], ary[i][1]];
        }
        return result;
    }

    /*
        回転には行列の考え方を利用した。
        コードは長くなったが、
        要は回転後にミノが他のブロックとぶつかったりする場合、
        回転をなかったことにする。(データベースのトランザクション的な)
    */
    // 左に90度回転
    rotateLeft(field) {
        let ary = Mino.myCopy(this.blocks);
        try {
            let overBottom = 0;
            for (let i = 0; i < Mino.NUM; i++) {
                let m = this.blocks[i];
                field[m[1]][m[0]].setLit(false);
                let x = m[0] - this.x;
                let y = m[1] - this.y;
                [x, y] = [-y, x];
                [m[0], m[1]] = [this.x + x, this.y + y];

                if (m[1] >= Game.h || field[m[1]][m[0]]) {
                    let temp = 0;
                    let d = m[1];
                    while (d >= Game.h || field[d][m[0]].getIsLocked()) {
                        d--;
                        temp++;
                    }
                    overBottom = this.p.max(overBottom, temp);
                }

            }

            for (let i = 0; i < Mino.NUM; i++) {
                this.y -= overBottom;
                this.blocks[i][1] -= overBottom;
            }
        } catch (e) {
            if (e instanceof TypeError) {
                this.blocks = ary;
            } else {
                console.error(e);
            }
        }
    }
    
    // 右に90度回転
    rotateRight(field) {
        let ary = Mino.myCopy(this.blocks);
        try {
            let overBottom = 0;
            for (let i = 0; i < Mino.NUM; i++) {
                let m = this.blocks[i];
                field[m[1]][m[0]].setLit(false);
                let x = m[0] - this.x;
                let y = m[1] - this.y;
                [x, y] = [y, -x];
                [m[0], m[1]] = [this.x + x, this.y + y];

                if (m[1] >= Game.h || field[m[1]][m[0]]) {
                    let temp = 0;
                    let d = m[1];
                    while (d >= Game.h || field[d][m[0]].getIsLocked()) {
                        d--;
                        temp++;
                    }
                    overBottom = this.p.max(overBottom, temp);
                }
            }

            for (let i = 0; i < Mino.NUM; i++) {
                this.y -= overBottom;
                this.blocks[i][1] -= overBottom;
            }
        } catch (e) {
            if (e instanceof TypeError) {
                this.blocks = ary;
            } else {
                console.error(e);
            }
        }
    }

    // 着地したブロックを固定
    lock(game) {
        let field = game.field;
        let top = 10 ** 9;;
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i];
            field[m[1]][m[0]].setLit(true);
            field[m[1]][m[0]].setIsLocked(true);
            top = this.p.min(top, m[1]);
        }
        this.isActive = false;
        game.top = this.p.min(game.top, top);
    }
    
    draw(game) {
        let field = game.field;
        if (!this.isActive) {
            return;
        }
        if (this.judgeBottom(field) && this.p.frameCount % 30 == 0) {
            this.lock(game);
            game.breakOut();
            return;
        }
        
        // キーボード ["j", "k", "l", "a", "d"] でミノを操作
        if (this.p.keyIsPressed && this.p.frameCount % 6 == 0) {
            switch (this.p.key) {
                case "j": //左に1マス移動
                    this.moveLeft(field);
                    break
                    case "k": //下に2マス移動
                        this.moveDown(field);
                        this.moveDown(field);
                        this.moveDown(field);
                    break;
                case "l": //右に1マス移動
                    this.moveRight(field);
                    break
                case "a": //左に90度回転
                    this.rotateLeft(field);
                    break;
                case "d": //右に90度回転
                    this.rotateRight(field);
                    break;
            }
        }

        //game.fallSpeedミリ秒おきに下に移動
        if (this.p.frameCount % game.fallSpeed === 0) {
            this.moveDown(field);
        }

        // ここでミノを表示
        for (let i = 0; i < Mino.NUM; i++) {
            let m = this.blocks[i]
            let block = field[m[1]][m[0]]
            block.setDesign(this.pattern);
            block.setLit(true);
        }
    }
}

class Mylib {
    // メモリ使用率表示
    static showMemory(p, permiliseconds) {
        if (p.frameCount % permiliseconds !== 0) { return; }
        let memory = performance.memory;
        console.log(memory);
        let x = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
        console.log(`メモリ使用率: ${x * 100} %`);
        console.log(`----稼働時間: ${frameCount / 60}秒----`)
    }
    
    // 配列をシャッフル
    static shuffle(ary) {
        let len = ary.length;
        for (let i = len - 1; i >= 0; i--) {
            let j = Math.floor(Math.random() * i);
            [ary[i], ary[j]] = [ary[j], ary[i]];
        }
    }

    // s ~ tまでの整数をランダム生成
    static rand(s, t) {
        return s + Math.floor(Math.random() * t)
    }

    static removeExtname(filename) {
        let result = "";
        for (let i = 0; i < filename.length; i++) {
            if (filename[i] === ".") break;
            result += filename[i];
        }
        return result;
    }
}

class Pattern {
    static NUM = 7;

    static SHAPES = [
        [[-1, 0], [0, -1], [0, 0], [1, 0]], //凸
        [[0, 0], [0, 1], [1, 1], [2, 1]], //「
        [[0, 0], [1, 0], [2, 0], [2, -1]], // 「の反対
        [[0, 0], [1, 0], [1, 1], [0, 1]], //口
        [[0, -1], [0, 0], [0, 1], [0, 2]], //|
        [[-1, 0], [0, 0], [0, 1], [1, 1]], //乙
        [[-1, 0], [0, 0], [0, -1], [1, -1]], //乙の反対
    ];

    static DESINGS = new Array(Pattern.NUM + 1);
    static setDesign(p) {
        for (let i = 0; i < Pattern.NUM + 1; i++) {
            Pattern.DESINGS[i] = p.loadImage(`assets/img/tetris/pattern${i}.png`);
        }
        Pattern.scoreBoad = p.loadImage("assets/img/tetris/score_boad.png");
    }

}

const Manager = require("./manager.min.js");
exports.Game = Game;
exports.Mino = Mino;
exports.Block = Block;
exports.Pattern = Pattern;
exports.Background = Background;
exports.Mylib = Mylib;
